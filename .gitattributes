# Auto detect text files and perform LF normalization
* text=auto// Copyright (c) 2005, Google Inc.
// Все права защищены.
//
// Перераспределение и использование в исходных и двоичных формах, с или без
// модификация допускается при соблюдении следующих условий
// met:
//
// * Распространение исходного кода должно сохранять вышеуказанные авторские права
// обратите внимание, этот список условий и следующий отказ от ответственности.
// * Перераспределения в двоичной форме должны воспроизводить вышесказанное
// уведомление об авторских правах, этот список условий и следующий отказ от ответственности
// в документации и/или других материалах, прилагаемых к
// распространение.
// * Ни название Google Inc., ни имена его
// участники могут использоваться для поддержки или продвижения продуктов, полученных из
// это программное обеспечение без специального предварительного письменного разрешения.
//
// ЭТО ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ ПРАВООБЛАДАТЕЛЯМИ И АВТОРАМИ
// "КАК ЕСТЬ" И ЛЮБЫЕ ЯВНЫЕ ИЛИ ПОДРАЗУМЕВАЕМЫЕ ГАРАНТИИ, ВКЛЮЧАЯ, НО НЕ
/ПОДРАЗУМЕВАЕМЫЕ ГАРАНТИИ ТОВАРНОЙ ПРИГОДНОСТИ И ПРИГОДНОСТИ ДЛЯ
// ОТ КОНКРЕТНОЙ ЦЕЛИ ОТКАЗЫВАЮТСЯ. НИ В КОЕМ СЛУЧАЕ АВТОРСКОЕ ПРАВО
// ВЛАДЕЛЕЦ ИЛИ УЧАСТНИКИ НЕСУТ ОТВЕТСТВЕННОСТЬ ЗА ЛЮБЫЕ ПРЯМЫЕ, КОСВЕННЫЕ, СЛУЧАЙНЫЕ,
// ОСОБЫЕ, ПРИМЕРНЫЕ ИЛИ КОСВЕННЫЕ УБЫТКИ (ВКЛЮЧАЯ, НО НЕ
// ОГРАНИЧИВАЕТСЯ ЗАКУПКОЙ ЗАМЕНЯЮЩИХ ТОВАРОВ ИЛИ УСЛУГ; ПОТЕРЯ ИСПОЛЬЗОВАНИЯ,
// ДАННЫЕ, ИЛИ ПРИБЫЛЬ; ИЛИ ПРЕРЫВАНИЕ БИЗНЕСА), НЕЗАВИСИМО ОТ ПРИЧИН И НА ЛЮБОМ
// ТЕОРИЯ ОТВЕТСТВЕННОСТИ, БУДЬ ТО В КОНТРАКТЕ, СТРОГОЙ ОТВЕТСТВЕННОСТИ ИЛИ ДЕЛИКТЕ
// (ВКЛЮЧАЯ ХАЛАТНОСТЬ ИЛИ ИНОЕ), ВОЗНИКШЕЕ КАКИМ-ЛИБО ОБРАЗОМ В РЕЗУЛЬТАТЕ ИСПОЛЬЗОВАНИЯ
// ДАННОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ, ДАЖЕ ЕСЛИ ВЫ ПРЕДУПРЕЖДЕНЫ О ВОЗМОЖНОСТИ ТАКОГО ПОВРЕЖДЕНИЯ.

// ---
// Автор: Крейг Сильверстайн
//
// Плотная хэш-таблица-это конкретная реализация
// хэш-таблица: та, которая предназначена для минимизации выделения памяти.
// Он делает это с помощью массива для хранения всех данных. Мы
// украсть значение из пространства ключей, чтобы указать "пустой" массив
// элементы (т. е. Индексы, в которых элемент не живет) и еще один для обозначения
// "удаленные" элементы.
//
/(Примечание можно изменить значение ключа удаления
// на лету; вы даже можете удалить его, хотя после этого момента
// хэш-таблица insert_only до тех пор, пока вы не установите ее снова. Пустой
/однако значение не может быть изменено.)
//
// Чтобы минимизировать распределение и накладные расходы указателей, мы используем внутренние
// зондирование, в котором хэш-таблица представляет собой одну таблицу, и коллизии
// решаются при попытке вставить снова в другое ведро. В
/наиболее эффективными схемами внутреннего зондирования являются линейные зондирования
// (который страдает, увы, от слипания) и квадратичное зондирование, которое
// - это то, что мы реализуем по умолчанию.
//
// Требования к типу: value_type должен быть копируемым
// и конструктивный по умолчанию. Это не обязательно (и обычно
// не) назначается.
//
// Вероятно, вам не следует использовать этот код напрямую. Использование
// <google/dense_hash_map> или <google/dense_hash_set> вместо этого.

// Вы можете изменить следующее ниже:
// HT_OCCUPANCY_PCT-насколько полно, прежде чем мы удвоим размер
// HT_EMPTY_PCT-как пусто, прежде чем мы уменьшим размер вдвое
// HT_MIN_BUCKETS -- наименьший размер ведра по умолчанию
//
// Вы также можете изменить enlarge_factor (который по умолчанию равен
// HT_OCCUPANCY_PCT) и shrink_factor (который по умолчанию равен
// HT_EMPTY_PCT) с set_resizing_parameters().
//
// Как решить, какие значения использовать?
/значение shrink_factor по умолчанию .4 * OCCUPANCY_PCT, вероятно, хорошо.
// HT_MIN_BUCKETS, вероятно, не нужен, так как вы можете указать
// (косвенно) начальное количество ведер во время построения.
// Для enlarge_factor вы можете использовать этот график, чтобы попытаться найти компромисс
// ожидаемое время поиска до занимаемого пространства. По умолчанию это
// код использует квадратичное зондирование, хотя вы можете изменить его на линейный
// через _JUMP ниже, если вы действительно хотите.
//
// От http://www.augustana.ca/~mohrj/courses/1999.fall/csc210/lecture_notes/hashing.html
// КОЛИЧЕСТВО ПРОБ / ПОИСК Успешный Неудачный
// Разрешение квадратичных столкновений 1 - ln(1-L) - L/2 1/(1-L) - L - ln(1-L)
// Линейное разрешение столкновений [1+1/(1-L)]/2 [1+1/(1-L)2]/2
//
// -- enlarge_factor -- 0.10 0.50 0.60 0.75 0.80 0.90 0.99
// КВАДРАТИЧНЫЕ КОЛЛИЗИИ.
// зонды/успешный поиск 1.05 1.44 1.62 2.01 2.21 2.85 5.11
// зонды/неудачный поиск 1.11 2.19 2.82 4.64 5.81 11.4 103.6
// LINEAR COLLISION RES.
// зонды/успешный поиск 1.06 1.5 1.75 2.5 3.0 5.5 50.5
// зонды/неудачный поиск 1.12 2.5 3.6 8.5 13.0 50.0 5000.0

#ifndef _DENSEHASHTABLE_H_
#define _DENSEHASHTABLE_H_

// Метод зондирования
// Линейное зондирование
// #define JUMP_(ключ, num_probes) ( 1 )
// Квадратичное зондирование
#определить JUMP_(ключ, num_probes) ( num_probes )


#включить <google/sparsehash/sparseconfig.h>
#включить <stdio.h>
#включить <assert.h>
#включить <stdlib.h>>             // для функции abort()
#включить <алгоритм>>            // Для swap(), например
#включить <stdexcept>>            // Для length_error
#включить <iostream>>             // Для cerr
#включить <память>>               // Для ininitialized_fill, uninitialized_copy
#включить <утилита>>              // для пары<>
#включить <итератор>>             // для фактов о тегах итератора
#включить <limits>>               // для numeric_limits<>
#включить <google/sparsehash/libc_allocator_with_realloc.h>
#включить <google/sparsehash/hashtable-common.h>
#включить <google/type_traits.h>> // для true_type, integral_constant и т. Д.

_START_GOOGLE_NAMESPACE_

использование STL_NAMESPACE::pair;

// Класс Hashtable, используемый для реализации хешированных ассоциативных контейнеров
// hash_set и hash_map.

// Value: то, что хранится в таблице (каждое ведро-это значение).
// Ключ: что-то в 1-к-1 соответствии со значением, которое можно использовать
// для поиска значения в таблице (find() принимает ключ).
// HashFcn: принимает ключ и возвращает целое число, чем уникальнее, тем лучше.
// ExtractKey: заданное значение возвращает уникальный ключ, связанный с ним.
// Должен наследовать от unary_function или, по крайней мере, иметь
// result_type перечисление, указывающее тип возвращаемого оператора().
// SetKey: учитывая значение* и ключ, изменяет значение таким образом, что
// ExtractKey(value) == ключ. Мы гарантируем, что это только называется
// с ключом == deleted_key или ключом == empty_key.
// EqualKey: учитывая два ключа, говорит, являются ли они одинаковыми (то есть,
// если они оба связаны с одним и тем же значением).
// Alloc: распределитель STL для выделения памяти.

шаблон < значение класса , ключкласса, класс HashFcn,
          класс ExtractKey, класс SetKey, класс EqualKey, класс Alloc>
класс dense_hashtable;

шаблон <класс V, класс K, класс HF, класс ExK, класс SetK, класс EqK, класс A>
структура dense_hashtable_iterator;

шаблон <класс V, класс K, класс HF, класс ExK, класс SetK, класс EqK, класс A>
структура dense_hashtable_const_iterator;

// Мы просто массив, но нам нужно пропустить пустые и удаленные элементы
шаблон <класс V, класс K, класс HF, класс ExK, класс SetK, класс EqK, класс A>
структура dense_hashtable_iterator {
 Частное:
  typedef typename A::template rebind<V>::other value_alloc_type;

 public:
  typedef dense_hashtable_iterator<V,K,HF,ExK,SetK,EqK,A> итератор;
  typedef dense_hashtable_const_iterator<V,K,HF,ExK,SetK,EqK,A> const_iterator;

  typedef STL_NAMESPACE::forward_iterator_tag iterator_category;
  typedef V value_type;
  typedef typename value_alloc_type::difference_type difference_type;
  typedef typename value_alloc_type::size_type size_type;
  typedef typename value_alloc_type::ссылка ссылка;
  typedef typename value_alloc_type::указатель указатель;

  // "Реальный" конструктор и конструктор по умолчанию
  dense_hashtable_iterator(const dense_hashtable<V,K,HF,ExK,SetK,EqK,A> *h,
 pointer it, pointer it_end, bool advance)
 : ht(h), pos(it), end(it_end) {
    if (advance) advance_past_empty_and_deleted();
  }
  dense_hashtable_iterator() { }
  // Деструктор по умолчанию в порядке; мы его не определяем
  // Оператор по умолчанию= в порядке; мы его не определяем

  // Счастливый разыменователь
 оператор ссылки*() const { return *pos; }
 оператор указателя->() const { return &(operator*()); }

  // Арифметика. Единственная трудная часть-убедиться, что
  // мы не находимся на пустом или помеченном-удаленном элементе массива
  void advance_past_empty_and_deleted() {
    while ( pos != end && (ht->test_empty(*this) || ht->test_deleted(*this)) )
 ++pos;
  }
  iterator& operator++()   {
    assert(pos != end); ++pos; advance_past_empty_and_deleted(); return *this;
  }
  iterator operator++(int) { iterator tmp(*this); ++*this; return tmp; }

  // Comparison.
  bool operator==(const iterator& it) const { return pos == it.pos; }
  bool operator!=(const iterator& it) const { return pos != it.pos; }


  // The actual data
  const dense_hashtable<V,K,HF,ExK,SetK,EqK,A> *ht;
  pointer pos, end;
};


// Now do it all again, but with const-ness!
template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
struct dense_hashtable_const_iterator {
 private:
  typedef typename A::template rebind<V>::other value_alloc_type;

 public:
  typedef dense_hashtable_iterator<V,K,HF,ExK,SetK,EqK,A> итератор;
  typedef dense_hashtable_const_iterator<V,K,HF,ExK,SetK,EqK,A> const_iterator;

  typedef STL_NAMESPACE::forward_iterator_tag iterator_category;
  typedef V value_type;
  typedef typename value_alloc_type::difference_type difference_type;
  typedef typename value_alloc_type::size_type size_type;
  typedef typename value_alloc_type::ссылка на const_reference;
  typedef typename value_alloc_type::указатель const_pointer;

  // "Реальный" конструктор и конструктор по умолчанию
  dense_hashtable_const_iterator(
      const dense_hashtable<V,K,HF,ExK,SetK,EqK,A> *h,
 pointer it, pointer it_end, bool advance)
 : ht(h), pos(it), end(it_end) {
    if (advance) advance_past_empty_and_deleted();
  }
  dense_hashtable_const_iterator()
 : ht(NULL), pos(pointer()), end(pointer()) { }
  // Это позволяет нам конвертировать обычные итераторы в постоянные итераторы
  dense_hashtable_const_iterator(const iterator &it)
 : ht(it.ht), pos(it.pos), end(it.end) { }
  // Деструктор по умолчанию в порядке; мы его не определяем
  // Оператор по умолчанию= в порядке; мы его не определяем

  // Счастливый разыменователь
 оператор ссылки*() const { return *pos; }
 оператор указателя->() const { return &(operator*()); }

  // Арифметика. Единственная трудная часть-убедиться, что
  // мы не находимся на пустом или помеченном-удаленном элементе массива
  void advance_past_empty_and_deleted() {
    while ( pos != end && (ht->test_empty(*this) || ht->test_deleted(*this)) )
 ++pos;
  }
 const_iterator& operator++() {
    assert(pos != end); ++pos; advance_past_empty_and_deleted(); return *this;
  }
 const_iterator operator++(int) { const_iterator tmp(*this); ++*this; return tmp; }

  // Сравнение.
   оператор bool==(const const_iterator& it) const { return pos == it.pos; }
   оператор bool!=(const const_iterator& it) const { return pos != it.pos; }


  // Фактические данные
  const dense_hashtable<V,K,HF,ExK,SetK,EqK,A> *ht;
  pointer pos, end;
};

template <class Value, class Key, class HashFcn,
          class ExtractKey, class SetKey, class EqualKey, class Alloc>
class dense_hashtable {
 private:
  typedef typename Alloc::template rebind<Value>::other value_alloc_type;

 public:
  typedef Key key_type;
  typedef Value value_type;
  typedef HashFcn hasher;
  typedef EqualKey key_equal;
  typedef Alloc allocator_type;

  typedef typename value_alloc_type::size_type size_type;
  typedef typename value_alloc_type::difference_type difference_type;
  typedef typename value_alloc_type::reference reference;
  typedef typename value_alloc_type::const_reference const_reference;
  typedef typename value_alloc_type::pointer pointer;
  typedef typename value_alloc_type::const_pointer const_pointer;
  typedef dense_hashtable_iterator<Значение, ключ, HashFcn,
 ExtractKey, SetKey, EqualKey, Alloc>
 итератор;

  typedef dense_hashtable_const_iterator<Значение, ключ, HashFcn,
 ExtractKey, SetKey, EqualKey, Alloc>
 const_iterator;

  // Они приходят из tr1. Для нас они такие же, как обычные итераторы.
  итератор typedef local_iterator;
  typedef const_iterator const_local_iterator;

  // Насколько полной мы позволяем таблице получить, прежде чем мы изменим размер, по умолчанию.
  // Кнут говорит, что .8-это хорошо-выше заставляет нас слишком много исследовать,
  // хотя это экономит память.
  static const int HT_OCCUPANCY_PCT; // = 50 (из 100)

  // Как пусто мы позволяем таблице получить, прежде чем мы изменим размер ниже, по умолчанию.
  // (0.0 означает никогда не изменять размер ниже.)
  // Это должно быть меньше, чем OCCUPANCY_PCT / 2 или мы изменим размер
  статический const int HT_EMPTY_PCT; // = 0.4 * HT_OCCUPANCY_PCT;

  // Минимальный размер мы готовы позволить хэш-таблицам быть.
  // Должна быть степень два и не менее 4.
  /Обратите внимание, однако, что для данной хэш-таблицы начальный размер
  // функция первого конструктора arg, и может быть >HT_MIN_BUCKETS.
  статическая константа size_type HT_MIN_BUCKETS = 4;

  // По умолчанию, если вы не указываете размер хэш-таблицы в
  // время строительства, мы используем этот размер. Должна быть степень два, и
  // как минимум HT_MIN_BUCKETS.
  статическая константа size_type HT_DEFAULT_STARTING_BUCKETS = 32;

  // ФУНКЦИИ ИТЕРАТОРА
 iterator begin() { возвращает iterator(this, table,
 таблица + num_buckets, true); }
 iterator end() { return iterator(this, table + num_buckets,
 таблица + num_buckets, true); }
 const_iterator begin() const { возвращает const_iterator(this, table,
 таблица+num_buckets,true);}
 const_iterator end() const { возвращает const_iterator(this, table + num_buckets,
 таблица+num_buckets,true);}

  // Они приходят из tr1 unordered_map. Они перебирают "ведро" n.
  // Мы просто рассмотрим ведро n как n-й элемент таблицы.
 local_iterator begin(size_type i) {
    возвращает local_iterator(this, table + i, table + i+1, false);
  }
  local_iterator end(size_type i) {
    local_iterator it = begin(i);
    if (!test_empty(i) && !test_deleted(i))
      ++it;
    return it;
  }
  const_local_iterator begin(size_type i) const {
    return const_local_iterator(this, table + i, table + i+1, false);
  }
  const_local_iterator end(size_type i) const {
    const_local_iterator it = begin(i);
    if (!test_empty(i) && !test_deleted(i))
      ++it;
    return it;
  }

  // ACCESSOR FUNCTIONS for the things we templatize on, basically
  hasher hash_funct() const               { return settings; }
  key_equal key_eq() const                { return key_info; }
  allocator_type get_allocator() const {
    return allocator_type(val_info);
  }

  // Accessor function for statistics gathering.
  int num_table_copies() const { return settings.num_ht_copies(); }

 private:
  // Annoyingly, we can't copy values around, because they might have
  // const components (they're probably pair<const X, Y>).  We use
  // explicit destructor invocation and placement new to get around
  // this.  Arg.
  void set_value(pointer dst, const_reference src) {
    dst->~value_type();   // delete the old value, if any
    new(dst) value_type(src);
  }

  void destroy_buckets(size_type first, size_type last) {
    for ( ; first != last; ++first)
      table[first].~value_type();
  }

  // DELETE HELPER FUNCTIONS
  // This lets the user describe a key that will indicate deleted
  // table entries.  This key should be an "impossible" entry --
  // if you try to insert it for real, you won't be able to retrieve it!
  // (NB: while you pass in an entire value, only the key part is looked
  // at. Это просто потому, что я не знаю, как назначить только ключ.)
 Частное:
  void squash_deleted() { // избавляется от любых удаленных записей, которые у нас есть
    if ( num_deleted ) { // избавиться от удаленного перед записью
 dense_hashtable tmp(*this); // копирование избавит от удаленных
      swap(tmp); // теперь мы tmp
    }
    assert(num_deleted == 0);
  }

  bool test_deleted_key(const key_type& key) const {
    // Тест num_deleted имеет решающее значение для read(): после read () значения ht
    // являются мусором, и мы не хотим думать, что некоторые из них удалены.
    /Инвариант: !use_deleted подразумевает, что num_deleted равно 0.
    assert(настройки.use_deleted() || num_deleted == 0);
    return num_deleted > 0 && equals(key_info.delkey, key);
  }

 public:
  void set_deleted_key(const key_type &key) {
    // пустой индикатор (если указан) и удаленный индикатор
    // должен быть другим
    assert((!настройки.use_empty() || !equals(key, get_key(val_info.emptyval)))
 && "Передал пустой ключ set_deleted_key");
    // Безопасно изменить то, что означает "удалено", только если мы удалим удаленных парней
    squash_deleted();
 Настройки.set_use_deleted(true);
 key_info.delkey = ключ;
  }
  void clear_deleted_key() {
    squash_deleted();
 Настройки.set_use_deleted(false);
  }
 key_type deleted_key() const {
    assert(настройки.use_deleted()
 && "Необходимо установить удаленный ключ перед вызовом deleted_key");
    вернуть key_info.delkey;
  }

  // Они являются общедоступными, поэтому итераторы могут их использовать
  // True, если элемент в позиции bucknum является маркером "deleted" 
  bool test_deleted(size_type bucknum) const {
    возврат test_deleted_key(get_key(table[bucknum]));
  }
  bool test_deleted(const iterator &it) const {
    возврат test_deleted_key(get_key(*it));
  }
  bool test_deleted(const const_iterator &it) const {
    возврат test_deleted_key(get_key(*it));
  }

 private:
  // Set it so test_deleted is true.  true if object didn't used to be deleted.
  bool set_deleted(iterator &it) {
    assert(settings.use_deleted());
    bool retval = !test_deleted(it);
    // &* converts from iterator to value-type.
    set_key(&(*it), key_info.delkey);
    return retval;
  }
  // Set it so test_deleted is false.  true if object used to be deleted.
  bool clear_deleted(iterator &it) {
    assert(settings.use_deleted());
    // Happens automatically when we assign something else in its place.
    return test_deleted(it);
  }

  // Мы также разрешаем устанавливать/очищать удаленный бит на итераторе const.
  // Мы разрешаем const_iterator по той же причине, по которой вы можете удалить
  // const указатель: это удобно, и семантически вы не можете использовать
  // "это" после того, как оно все равно было удалено, поэтому его константа не
  // действительно имеет значение.
  bool set_deleted(const_iterator &it) {
    assert(настройки.use_deleted());
    bool retval = !test_deleted(it);
    set_key(const_cast<pointer>(&(*it)), key_info.delkey);
    вернуть retval;
  }
  // Установите так, чтобы test_deleted было false. true, если объект был удален.
  bool clear_deleted(const_iterator &it) {
    assert(настройки.use_deleted());
    возврат test_deleted(it);
  }

  // ПУСТЫЕ ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
  // Это позволяет пользователю описать ключ, который будет указывать пустой (неиспользуемый)
  // записи таблицы. Этот ключ должен быть "невозможной" записью --
  // если вы попытаетесь вставить его по-настоящему, вы не сможете его получить!
  // (NB: пока вы передаете целое значение, просматривается только ключевая часть
  // at. Это просто потому, что я не знаю, как назначить только ключ.)
 public:
  // Они являются общедоступными, поэтому итераторы могут их использовать
  // True, если элемент в позиции bucknum является "пустым" маркером
  bool test_empty(size_type bucknum) const {
    assert(настройки.use_empty()); // нам всегда нужно знать, что пусто!
    return equals(get_key(val_info.emptyval), get_key(table[bucknum]));
  }
  bool test_empty(const iterator &it) const {
    assert(настройки.use_empty()); // нам всегда нужно знать, что пусто!
    return equals(get_key(val_info.emptyval), get_key(*it));
  }
  bool test_empty(const const_iterator &it) const {
    assert(настройки.use_empty()); // нам всегда нужно знать, что пусто!
    return equals(get_key(val_info.emptyval), get_key(*it));
  }

 Частное:
  void fill_range_with_empty(указатель table_start, указатель table_end) {
    STL_NAMESPACE::uninitialized_fill(table_start, table_end, val_info.emptyval);
  }

 public:
  // TODO(csilvers): измените всех вызывающих, чтобы вместо этого передать ключ,
  // и возьмите const key_type вместо const value_type.
  void set_empty_key(const_reference val) {
    // Как только вы установите пустой ключ, вы не сможете его изменить
    assert(!настройки.use_empty() && "Вызов set_empty_key несколько раз");
    // Удаленный индикатор (если указан) и пустой индикатор
    // должен быть другим.
    assert((!настройки.use_deleted() || !equals(get_key(val), key_info.delkey))
 && "Установка пустого ключа так же, как удаленный ключ");
 Настройки.set_use_empty(true);
    set_value(&val_info.emptyvalвал, val);

    assert(!table); // должен быть установлен перед первым использованием
    // num_buckets был установлен в конструкторе, хотя таблица была нулевой
 таблица = val_info.allocate(num_buckets);
    assert(таблица);
    fill_range_with_empty(таблица, таблица + num_buckets);
  }
  // TODO(sjackman): возвращает key_type, а не value_type
 value_type empty_key() const {
    assert(настройки.use_empty());
    вернуть val_info.emptyvalв;
  }

  // ФУНКЦИИ, КАСАЮЩИЕСЯ РАЗМЕРА
 public:
 size_type size() const { return num_elements - num_deleted; }
 size_type max_size() const { return val_info.max_size(); }
  bool empty() const { return size() == 0; }
 size_type bucket_count() const { return num_buckets; }
 size_type max_bucket_count() const { return max_size(); }
 size_type nonempty_bucket_count() const { возвращает num_elements; }
  // Это методы tr1. Их идея "ведра" плохо соотносится с
  // что мы делаем. Мы просто говорим, что в каждом ведре есть 0 или 1 элемент.
 size_type bucket_size(size_type i) const {
    return begin(i) == end(i) ? 0 : 1;
  }

 Частное:
  // Из-за вышеизложенного size_type(-1) никогда не является законным; используйте его для ошибок
  статическая константа size_type ILLEGAL_BUCKET = size_type(-1);

  // Используется после строки удалений. Возвращает true, если мы действительно сократились.
  // TODO(csilvers): возьмите дельту, чтобы мы могли учитывать вставки
  // сделано после сжатия. Может быть, сделать часть класса настроек?
  bool maybe_shrink() {
    assert(num_elements >= num_deleted);
    assert((bucket_count() & (bucket_count()-1)) == 0); // is a power of two
    assert(bucket_count() >= HT_MIN_BUCKETS);
    bool retval = false;

    // Если вы создаете хэш-таблицу с,
    // мы никогда не уменьшимся, пока вы не станете относительно большим, и мы никогда
    // сокращение ниже HT_DEFAULT_STARTING_BUCKETS. В противном случае что-то
    // как "dense_hash_set<int> x; x.insert(4); x.erase(4);" будет
    // сократите нас до ведер HT_MIN_BUCKETS, которые слишком малы.
    const size_type num_remain = num_elements - num_deleted;
    const size_type shrink_threshold = настройки.shrink_threshold();
    if (shrink_threshold > >0 && num_remain &&
        bucket_count() > HT_DEFAULT_STARTING_BUCKETS) {
      const float shrink_factor = настройки.shrink_factor();
 size_type sz = bucket_count() / 2; // найти, сколько мы должны сжать
      while (sz > HT_DEFAULT_STARTING_BUCKETS &&
 num_remain < sz * shrink_factor) {
 sz /= 2; // оставайтесь в степени 2
      }
 dense_hashtable tmp(*this, sz); // Сделать фактическое изменение размера
      swap(tmp); // теперь мы tmp
 retval = true;
    }
 Настройки.set_consider_shrink(false); // потому что мы только что рассмотрели это
    вернуть retval;
  }

  // Мы позволим вам изменить размер хэш-таблицы-хотя это заставляет нас копировать все!
  // Когда вы изменяете размер, вы говорите: "Сделайте его достаточно большим для такого количества элементов"
  // Возвращает true, если мы действительно изменили размер, false, если размер уже был в порядке.
  bool resize_delta(size_type delta) {
    bool did_resize = false;
    если ( настройки.рассмотрите_shrink() ) { // посмотрите, произошло ли много удалений
      if ( maybe_shrink() )
 did_resize = true;
    }
    if (num_elements >= (STL_NAMESPACE::numeric_limits><size_type>::max)() - дельта)
      throw std::length_error("переполнение размера");
    if ( bucket_count() >= HT_MIN_BUCKETS &&
 (num_elements + delta) enlarge_threshold() )
      return did_resize; // у нас все в порядке

    // Иногда нам нужно изменить размер, чтобы избавиться от всех
    // "удаленные" ведра, которые засоряют хэш-таблицу. Итак, когда
    // решая, изменять ли размер, подсчитайте удаленные ведра (которые
    // в настоящее время занимают место). Но позже, когда мы решим, что
    // размер для изменения размера, *не* считать удаленные ведра, так как они
    // отбрасывается во время изменения размера.
    const size_type needed_size = настройки.min_buckets(num_elements + delta, 0);
    if ( needed_size <= bucket_count() ) // у нас достаточно ведер
      return did_resize;

    size_type resize_to =
      settings.min_buckets(num_elements - num_deleted + delta, bucket_count());

    if (resize_to < needed_size &&    // may double resize_to
        resize_to < (STL_NAMESPACE::numeric_limits<size_type>::max)() / 2) {
      // This situation means that we have enough deleted elements,
      // that once we purge them, we won't actually have needed to
      // grow.  But we may want to grow anyway: if we just purge one
      // element, say, we'll have to grow anyway next time we
      // insert.  Might as well grow now, since we're already going
      // through the trouble of copying (in order to purge the
      // deleted elements).
      const size_type target =
          static_cast<size_type>(settings.shrink_size(resize_to*2));
      if (num_elements - num_deleted + delta >= target) {
        // Good, we won't be below the shrink threshhold even if we double.
        resize_to *= 2;
      }
    }
    dense_hashtable tmp(*this, resize_to);
    swap(tmp);                             // now we are tmp
    return true;
  }

  // We require table be not-NULL and empty before calling this.
  void resize_table(size_type /*old_size*/, size_type new_size,
                    true_type) {
    table = val_info.realloc_or_die(table, new_size);
  }

  void resize_table(size_type old_size, size_type new_size, false_type) {
    val_info.deallocate(table, old_size);
    table = val_info.allocate(new_size);
  }

  // Used to actually do the rehashing when we grow/shrink a hashtable
  void copy_from(const dense_hashtable &ht, size_type min_buckets_wanted) {
    clear_to_size(settings.min_buckets(ht.size(), min_buckets_wanted));

    // We use a normal iterator to get non-deleted bcks from ht
    // We could use insert() here, but since we know there are
    // no duplicates and no deleted items, we can be more efficient
    assert((bucket_count() & (bucket_count()-1)) == 0);      // a power of two
    for ( const_iterator it = ht.begin(); it != ht.end(); ++it ) {
      size_type num_probes = 0;              // how many times we've probed
      size_type bucknum;
      const size_type bucket_count_minus_one = bucket_count() - 1;
      for (bucknum = hash(get_key(*it)) & bucket_count_minus_one;
           !test_empty(bucknum);                               // not empty
 bucknum = (bucknum + JUMP_(key, num_probes)) & bucket_count_minus_one) {
 ++num_probes;
        assert(num_probes < bucket_count()
 && "Хэш-таблица заполнена: ошибка в key_equal<> или hash<><><>");
      }
      set_value(&table[bucknum], *it); // копирует значение сюда
 num_elements++;
    }
 Настройки.inc_num_ht_copies();
  }

  // Требуется спецификацией для хэшированного ассоциативного контейнера
 public:
  // Хотя документы говорят, что это должно быть num_buckets, я думаю, что это намного
  // более полезно как num_elements. В качестве специальной функции вызов с
  // req_elements==0 заставит нас сжаться, если мы сможем, экономя пространство.
  void resize(size_type req_elements) { // изменить размер до этого или большего
    если ( настройки.рассмотрим() | | req_elements == 0 )
      maybe_shrink();
    if ( req_elements > num_elements )
      resize_delta(req_elements - num_elements);
  }

  // Получить и изменить значение shrink_factor и enlarge_factor. В
  // описание в начале этого файла объясняет, как выбрать
  // значения. Установка параметра shrink на 0.0 гарантирует, что
  // таблица никогда не сжимается.
  void get_resizing_parameters(float* shrink, float* grow) const {
 *shrink = настройки.shrink_factor();
 *grow = настройки.enlarge_factor();
  }
  void set_resizing_parameters(float shrink, float grow) {
 Настройки.set_resizing_parameters(shrink, grow);
 Настройки.reset_thresholds(bucket_count());
  }

  // КОНСТРУКТОРЫ - как того требуют спецификации, мы берем размер,
  // но также позволяет указать хэш-функцию, ключевой компаратор,
  // и экстрактор ключей. Мы также определяем конструктор копирования и =.
  // ДЕСТРУКТОР -- необходимо освободить таблицу
  явный dense_hashtable(size_type expected_max_items_in_table = 0,
                           const HashFcn& hf = HashFcn(),
                           const EqualKey& eql = EqualKey(),
                           const ExtractKey& ext = ExtractKey(),
                           const SetKey& set = SetKey(),
                           const Alloc& alloc = Alloc())
 : настройки(hf),
 key_info(ext, set, eql),
 num_deleted(0),
        num_elements(0),
        num_buckets(expected_max_items_in_table == 0
                    ? HT_DEFAULT_STARTING_BUCKETS
                    : settings.min_buckets(expected_max_items_in_table, 0)),
        val_info(alloc_impl<value_alloc_type>(alloc)),
        table(NULL) {
    // table is NULL until emptyval is set.  However, we set num_buckets
    // here so we know how much space to allocate once emptyval is set
    settings.reset_thresholds(bucket_count());
  }

  // As a convenience for resize(), we allow an optional second argument
  // which lets you make this new hashtable a different size than ht
  dense_hashtable(const dense_hashtable& ht,
                  size_type min_buckets_wanted = HT_DEFAULT_STARTING_BUCKETS)
      : settings(ht.settings),
        key_info(ht.key_info),
        num_deleted(0),
        num_elements(0),
        num_buckets(0),
        val_info(ht.val_info),
        table(NULL) {
    if (!ht.settings.use_empty()) {
      // If use_empty isn't set, copy_from will crash, so we do our own copying.
      assert(ht.empty());
      num_buckets = settings.min_buckets(ht.size(), min_buckets_wanted);
      settings.reset_thresholds(bucket_count());
      return;
    }
    settings.reset_thresholds(bucket_count());
    copy_from(ht, min_buckets_wanted);   // copy_from() ignores deleted entries
  }

  dense_hashtable& operator= (const dense_hashtable& ht) {
    if (&ht == this)  return *this;        // don't copy onto ourselves
    if (!ht.settings.use_empty()) {
      assert(ht.empty());
      dense_hashtable empty_table(ht);  // empty table with ht's thresholds
      this->swap(empty_table);
      return *this;
    }
    settings = ht.settings;
    key_info = ht.key_info;
    set_value(&val_info.emptyval, ht.val_info.emptyval);
    // copy_from() calls clear and sets num_deleted to 0 too
    copy_from(ht, HT_MIN_BUCKETS);
    // we purposefully don't copy the allocator, which may not be copyable
    return *this;
  }

  ~dense_hashtable() {
    если (таблица) {
      destroy_buckets(0, num_buckets);
 val_info.deallocate(таблица, num_buckets);
    }
  }

  // Многие алгоритмы STL используют swap вместо конструкторов копирования
  void swap(dense_hashtable& ht) {
    STL_NAMESPACE::swap(settings, ht.settings);
    STL_NAMESPACE::swap(key_info, ht.key_info);
    STL_NAMESPACE::swap(num_deleted, ht.num_deleted);
    STL_NAMESPACE::swap(num_elements, ht.num_elements);
    STL_NAMESPACE::swap(num_buckets, ht.num_buckets);
 { value_type tmp; // по раздражающим причинам swap() не работает
      set_value(&tmp, val_info.emptyval);
      set_value(&val_info.emptyval, ht.val_info.emptyval);
      set_value(&ht.val_info.emptyval, tmp);
    }
    STL_NAMESPACE::swap(table, ht.table);
 Настройки.reset_thresholds(bucket_count()); // это также сбрасывает consider_shrink
 ht.settings.reset_thresholds(bucket_count());
    // мы целенаправленно не меняем распределитель, который не может быть заменен
  }

 Частное:
  void clear_to_size(size_type new_num_buckets) {
    if (!таблица) {
 таблица = val_info.allocate(new_num_buckets);
 } else {
      destroy_buckets(0, num_buckets);
      if (new_num_buckets != num_buckets) { // изменить размер, если необходимо
        typedef integral_constant<bool,
 is_same,
 libc_allocator_with_realloc<value_type> <value_type>>::value<value_type>>>
 realloc_ok;
        resize_table(num_buckets, new_num_buckets, realloc_ok());
      }
    }
    assert(таблица);
    fill_range_with_empty(таблица, таблица + new_num_buckets);
 num_elements = 0;
 num_deleted = 0;
 num_buckets = new_num_buckets; // наш новый размер
 Настройки.reset_thresholds(bucket_count());
  }

 public:
  // Всегда приятно иметь возможность очистить таблицу, не освобождая ее
  void clear() {
    // If the table is already empty, and the number of buckets is
    // already as we desire, there's nothing to do.
    const size_type new_num_buckets = settings.min_buckets(0, 0);
    if (num_elements == 0 && new_num_buckets == num_buckets) {
      return;
    }
    clear_to_size(new_num_buckets);
  }

  // Clear the table without resizing it.
  // Mimicks the stl_hashtable's behaviour when clear()-ing in that it
  // does not modify the bucket count
  void clear_no_resize() {
    if (num_elements > 0) {
      assert(table);
      destroy_buckets(0, num_buckets);
      fill_range_with_empty(table, table + num_buckets);
    }
    // don't consider to shrink before another erase()
    settings.reset_thresholds(bucket_count());
    num_elements = 0;
    num_deleted = 0;
  }

  // LOOKUP ROUTINES
 private:
  // Returns a pair of positions: 1st where the object is, 2nd where
  // it would go if you wanted to insert it.  1st is ILLEGAL_BUCKET
  // if object is not found; 2nd is ILLEGAL_BUCKET if it is.
  // Note: because of deletions where-to-insert is not trivial: it's the
  // first deleted bucket we see, as long as we don't find the key later
  pair<size_type, size_type> find_position(const key_type &key) const {
    size_type num_probes = 0;              // how many times we've probed
    const size_type bucket_count_minus_one = bucket_count() - 1;
    size_type bucknum = hash(key) & bucket_count_minus_one;
    size_type insert_pos = ILLEGAL_BUCKET; // where we would insert
    while ( 1 ) {                          // probe until something happens
      if ( test_empty(bucknum) ) {         // bucket is empty
        if ( insert_pos == ILLEGAL_BUCKET )   // found no prior place to insert
          return pair<size_type,size_type>(ILLEGAL_BUCKET, bucknum);
        else
          return pair<size_type,size_type>(ILLEGAL_BUCKET, insert_pos);

      } else if ( test_deleted(bucknum) ) {// keep searching, but mark to insert
        if ( insert_pos == ILLEGAL_BUCKET )
          insert_pos = bucknum;

      } else if ( equals(key, get_key(table[bucknum])) ) {
        return pair<size_type,size_type>(bucknum, ILLEGAL_BUCKET);
      }
      ++num_probes;                        // we're doing another probe
      bucknum = (bucknum + JUMP_(key, num_probes)) & bucket_count_minus_one;
      assert(num_probes < bucket_count()
             && "Hashtable is full: an error in key_equal<> or hash<>");
    }
  }

 public:
  iterator find(const key_type& key) {
    if ( size() == 0 ) return end();
    pair<size_type, size_type> pos = find_position(key);
    if ( pos.first == ILLEGAL_BUCKET )     // alas, not there
      return end();
    else
      return iterator(this, table + pos.first, table + num_buckets, false);
  }

  const_iterator find(const key_type& key) const {
    if ( size() == 0 ) return end();
    pair<size_type, size_type> pos = find_position(key);
    if ( pos.first == ILLEGAL_BUCKET )     // alas, not there
      return end();
    ещё
      возвращает const_iterator(this, table + pos.first, table+num_buckets, false);
  }

  // Это метод tr1: ведро, в котором находится данный ключ, или какое ведро
  // он был бы вставлен, если бы он был вставлен. Пожать плечами.
 size_type bucket(const key_type& key) const {
 пара<size_type, size_type> pos = <size_type, size_type>find_position(ключ);
    вернуть pos.first == ILLEGAL_BUCKET ? pos.second : pos.first;
  }

  // Подсчитывает, сколько элементов имеют ключевой ключ. Для карт это либо 0, либо 1.
 size_type count(const key_type &key) const {
 пара<size_type, size_type> pos = <size_type, size_type>find_position(ключ);
    вернуть pos.first == ILLEGAL_BUCKET ? 0 : 1;
  }

  // Точно так же equal_range на самом деле не имеет смысла для нас. Ну ладно.
 pair<iterator,iterator> equal_range(const key_type& key) {
 iterator pos = find(key); // либо итератор, либо конец
    if (pos == end()) {
      возвращаемая пара<итератор,итератор>(pos, pos);
 } else {
      const итератор startpos = pos++;
      возвращаемая пара<iterator,iterator>(startpos, pos);
    }
  }
 pair<const_iterator,const_iterator> equal_range(const key_type& key) const {
 const_iterator pos = find(key); // либо итератор, либо конец
    if (pos == end()) {
      возвращаемая пара<const_iterator,const_iterator>(pos, pos);
 } else {
      const const_iterator startpos = pos++;
      возвращаемая пара<const_iterator,const_iterator>(startpos, pos);
    }
  }


  // ПРОЦЕДУРЫ ВСТАВКИ
 Частное:
  // Частный метод, используемый insert_noresize и find_or_insert.
 итератор insert_at(const_reference obj, size_type pos) {
    if (size() >= max_size())
      throw std::length_error("вставить переполнение");
    if ( test_deleted(pos) ) { // просто замените, если это было del.
      // shrug: не должно быть const.
 const_iterator delpos(this, table + pos, table + num_buckets, false);
      clear_deleted(delpos);
      assert( num_deleted > 0);
      --num_deleted;                // used to be, now it isn't
    } else {
      ++num_elements;               // replacing an empty bucket
    }
    set_value(&table[pos], obj);
    return iterator(this, table + pos, table + num_buckets, false);
  }

  // If you know *this is big enough to hold obj, use this routine
  pair<iterator, bool> insert_noresize(const_reference obj) {
    // First, double-check we're not inserting delkey or emptyval
    assert((!settings.use_empty() || !equals(get_key(obj),
                                             get_key(val_info.emptyval)))
           && "Inserting the empty key");
    assert((!settings.use_deleted() || !equals(get_key(obj), key_info.delkey))
           && "Inserting the deleted key");
    const pair<size_type,size_type> pos = find_position(get_key(obj));
    if ( pos.first != ILLEGAL_BUCKET) {      // object was already there
      return pair<iterator,bool>(iterator(this, table + pos.first,
                                          table + num_buckets, false),
                                 false);          // false: we didn't insert
    } else {                                 // pos.second says where to put it
      return pair<iterator,bool>(insert_at(obj, pos.second), true);
    }
  }

  // Specializations of insert(it, it) depending on the power of the iterator:
  // (1) Iterator supports operator-, resize before inserting
  template <class ForwardIterator>
  void insert(ForwardIterator f, ForwardIterator l, STL_NAMESPACE::forward_iterator_tag) {
    size_t dist = STL_NAMESPACE::distance(f, l);
    if (dist >= (std::numeric_limits<size_type>::max)())
      throw std::length_error("insert-range overflow");
    resize_delta(static_cast<size_type>(dist));
    for ( ; dist > 0; --dist, ++f) {
      insert_noresize(*f);
    }
  }

  // (2) Произвольный итератор, не может сказать, сколько изменить размер
  шаблон <класс InputIterator>
  void insert(InputIterator f, InputIterator l, STL_NAMESPACE::input_iterator_tag) {
    for ( ; f != l; ++f)
      вставка(*f);
  }

 public:
  // Это обычная процедура вставки, используемая внешним миром
 pair<iterator, bool> insert(const_reference obj) {
    resize_delta(1); // добавление объекта, расти, если это необходимо
    возврат insert_noresize(obj);
  }

  // При вставке много за раз мы специализируемся на типе итератора
  шаблон <класс InputIterator>
   вставка void(InputIterator f, InputIterator l) {
    // специализируется на типе итератора
    insert(f, l, typename STL_NAMESPACE::iterator_traits<InputIterator>::iterator_category());
  }

  /defaultValue - это функтор, который принимает ключ и возвращает value_type
  // представляет значение по умолчанию, которое будет вставлено, если оно не найдено.
  шаблон <класс defaultValue>
 value_type& find_or_insert(const key_type& key) {
    // Во-первых, дважды проверьте, что мы не вставляем emptykey или delkey
    assert((!настройки.use_empty() || !equals(key, get_key(val_info.emptyval)))
 && "Вставка пустого ключа");
    assert((!настройки.use_deleted() || !equals(ключ, key_info.delkey))
 && "Вставка удаленного ключа");
    const pair<size_type,size_type> pos = <size_type,size_type>find_position(ключ);
 defaultValue default_value;
    if ( pos.first != ILLEGAL_BUCKET) { // объект уже был там
      таблица возврата[pos.first];
 } else if (resize_delta(1)) { // необходимо перефразировать, чтобы освободить место
      /Поскольку мы изменили размер, мы не можем использовать pos, поэтому пересчитайте, куда вставлять.
      return *insert_noresize(default_value(key)).Первый;
 } else { // не нужно перефразировать, вставьте прямо здесь
      return *insert_at(default_value(key), pos.second);
    }
  }

  // ПРОЦЕДУРЫ УДАЛЕНИЯ
 size_type erase(const key_type& key) {
    // Во-первых, дважды проверьте, что мы не пытаемся стереть delkey или emptyval.
    assert((!settings.use_empty() || !equals(key, get_key(val_info.emptyval)))
           && "Erasing the empty key");
    assert((!settings.use_deleted() || !equals(key, key_info.delkey))
           && "Erasing the deleted key");
    const_iterator pos = find(key);   // shrug: shouldn't need to be const
    if ( pos != end() ) {
      assert(!test_deleted(pos));  // or find() shouldn't have returned it
      set_deleted(pos);
      ++num_deleted;
      settings.set_consider_shrink(true); // will think about shrink after next insert
      return 1;                    // because we deleted one thing
    } else {
      return 0;                    // because we deleted nothing
    }
  }

  // We return the iterator past the deleted item.
  void erase(iterator pos) {
    if ( pos == end() ) return;    // sanity check
    if ( set_deleted(pos) ) {      // true if object has been newly deleted
      ++num_deleted;
      settings.set_consider_shrink(true); // will think about shrink after next insert
    }
  }

  void erase(iterator f, iterator l) {
    for ( ; f != l; ++f) {
      if ( set_deleted(f)  )       // should always be true
        ++num_deleted;
    }
    settings.set_consider_shrink(true); // will think about shrink after next insert
  }

  // We allow you to erase a const_iterator just like we allow you to
  // erase an iterator.  This is in parallel to 'delete': you can delete
  // a const pointer just like a non-const pointer.  The logic is that
  // you can't use the object after it's erased anyway, so it doesn't matter
  // if it's const or not.
  void erase(const_iterator pos) {
    if ( pos == end() ) return;    // sanity check
    if ( set_deleted(pos) ) {      // true if object has been newly deleted
      ++num_deleted;
      settings.set_consider_shrink(true); // will think about shrink after next insert
    }
  }
  void erase(const_iterator f, const_iterator l) {
    for ( ; f != l; ++f) {
      if ( set_deleted(f)  )       // should always be true
        ++num_deleted;
    }
    settings.set_consider_shrink(true);   // will think about shrink after next insert
  }


  // COMPARISON
  bool operator==(const dense_hashtable& ht) const {
    if (size() != ht.size()) {
      return false;
    } else if (this == &ht) {
      return true;
    } else {
      // Iterate through the elements in "this" and see if the
      // corresponding element is in ht
      for ( const_iterator it = begin(); it != end(); ++it ) {
        const_iterator it2 = ht.find(get_key(*it));
        if ((it2 == ht.end()) || (*it != *it2)) {
          return false;
        }
      }
      return true;
    }
  }
   оператор bool!=(const dense_hashtable& ht) const {
    return !(*this == ht);
  }


  // I/O
  // Мы поддерживаем чтение и запись хэш-таблиц на диск. Увы, поскольку
  // Я не знаю, как написать хэшер или key_equal, вы должны сделать
  // конечно, все, но таблица одинакова. Мы уплотняем, прежде чем писать
  //
  // ПРИМЕЧАНИЕ: Эти функции в настоящее время выполняются. Они не были реализованы.
  bool write_metadata(ФАЙЛ * /*fp*/) {
    squash_deleted(); // поэтому нам не нужно беспокоиться о delkey
    return false; // TODO
  }

  bool read_metadata(ФАЙЛ* /*fp*/) {
 num_deleted = 0; // так как мы избавились перед написанием
    assert(настройки.use_empty() && "empty_key не установлен для read_metadata");
    if (table) val_info.deallocate(table, num_buckets); // мы сделаем наш собственный
    // TODO: прочитать магическое число
    // TODO: read num_buckets
 Настройки.reset_thresholds(bucket_count());
 таблица = val_info.allocate(num_buckets);
    assert(таблица);
    fill_range_with_empty(таблица, таблица + num_buckets);
    // TODO: прочитать num_elements
    for ( size_type i = 0; i < num_elements; ++i ) {
      // TODO: read bucket_num
      // TODO: установить непустое, не удаленное значение
    }
    return false; // TODO
  }

  // Если ваши ключи и значения достаточно просты, мы можем записать их в
  // диск для вас. "достаточно просто" означает, что value_type-это тип POD
  // который не содержит указателей. Однако мы не пытаемся нормализовать
  // endianness
  bool write_nopointer_data(FILE *fp) const {
    for ( const_iterator it = begin(); it != end(); ++it ) {
      // TODO: пропустить пустые/удаленные значения
      if ( !fwrite(&*it, sizeof(*it), 1, fp) ) возвращает false;
    }
    возвращает false;
  }

  // При чтении мы должны переопределить потенциальную константу *it
  bool read_nopointer_data(ФАЙЛ *fp) {
    for ( iterator it = begin(); it != end(); ++it ) {
      // TODO: skip empty/deleted values
      if ( !fread(reinterpret_cast<void*>(&(*it)), sizeof(*it), 1, fp) )
        return false;
    }
    return false;
  }

 private:
  template <class A>
  class alloc_impl : public A {
   public:
    typedef typename A::pointer pointer;
    typedef typename A::size_type size_type;

    // Convert a normal allocator to one that has realloc_or_die()
    alloc_impl(const A& a) : A(a) { }

    // realloc_or_die should only be used when using the default
    // allocator (libc_allocator_with_realloc).
    pointer realloc_or_die(pointer /*ptr*/, size_type /*n*/) {
      fprintf(stderr, "realloc_or_die is only supported for "
                      "libc_allocator_with_realloc");
      exit(1);
      return NULL;
    }
  };

  // A template specialization of alloc_impl for
  // libc_allocator_with_realloc that can handle realloc_or_die.
  template <class A>
  class alloc_impl<libc_allocator_with_realloc<A> >
      : public libc_allocator_with_realloc<A> {
   public:
    typedef typename libc_allocator_with_realloc<A>::pointer pointer;
    typedef typename libc_allocator_with_realloc<A>::size_type size_type;

    alloc_impl(const libc_allocator_with_realloc<A>& a)
        : libc_allocator_with_realloc<A>(a) { }

    pointer realloc_or_die(pointer ptr, size_type n) {
      pointer retval = this->reallocate(ptr, n);
      if (retval == NULL) {
        // We really should use PRIuS here, but I don't want to have to add
        // a whole new configure option, with concomitant macro namespace
        // pollution, just to print this (unlikely) error message.  So I cast.
        fprintf(stderr, "sparsehash: FATAL ERROR: failed to reallocate "
                "%lu elements for ptr %p",
                static_cast<unsigned long>(n), ptr);
        exit(1);
      }
      return retval;
    }
  };

  // Package allocator with emptyval to eliminate memory needed for
  // the zero-size allocator.
  // If new fields are added to this class, we should add them to
  // operator= and swap.
  class ValInfo : public alloc_impl<value_alloc_type> {
   public:
    typedef typename alloc_impl<value_alloc_type>::value_type value_type;

    ValInfo(const alloc_impl<value_alloc_type>& a)
        : alloc_impl<value_alloc_type>(a), emptyval() { }
    ValInfo(const ValInfo& v)
        : alloc_impl<value_alloc_type>(v), emptyval(v.emptyval) { }

    value_type emptyval;    // which key marks unused entries
  };


  // Функторы пакетов с другим классом для устранения памяти, необходимой для
  // функторы нулевого размера. Поскольку ExtractKey и оператор хэшера() могут
  // имеют одинаковую сигнатуру функции, они должны быть упакованы в
  // разные классы.
   настройки структуры :
 sh_hashtable_settings<key_type, hasher, size_type, HT_MIN_BUCKETS> {
    явные настройки(const hasher& hf)
 : sh_hashtable_settings<key_type, hasher, size_type, HT_MIN_BUCKETS>(
 hf, HT_OCCUPANCY_PCT / 100.0f, HT_EMPTY_PCT / 100.0f) {}
  };

  // Пакеты ExtractKey и SetKey функторы.
  класс KeyInfo : public ExtractKey, public SetKey, public key_equal {
   public:
    KeyInfo(const ExtractKey& ek, const SetKey& sk, const key_equal& eq)
 : ExtractKey(ek),
          SetKey(sk),
 key_equal(eq) {
    }

    // Мы хотим вернуть точно такой же тип, как ExtractKey: Key или const Key&
    typename ExtractKey::result_type get_key(const_reference v) const {
      return ExtractKey::operator()(v);
    }
    void set_key(указатель v, const key_type& k) const {
      SetKey::operator()(v, k);
    }
    bool равно(const key_type& a, const key_type& b) const {
      return key_equal::operator()(a, b);
    }

    // Какой ключ помечает удаленные записи.
    // TODO(csilvers): сделайте указатель и избавьтесь от use_deleted (benchmark!)
    typename remove_const<key_type>::type delkey;
  };

  // Служебные функции для доступа к шаблонным операторам
 size_type hash(const key_type& v) const {
    возврат настроек.хэш(v);
  }
  bool равно(const key_type& a, const key_type& b) const {
    return key_info.equals(a, b);
  }
  typename ExtractKey::result_type get_key(const_reference v) const {
    вернуть key_info.get_key(v);
  }
  void set_key(указатель v, const key_type& k) const {
 key_info.set_key(v, k);
  }

 private:
  // Actual data
  Settings settings;
  KeyInfo key_info;

  size_type num_deleted;  // how many occupied buckets are marked deleted
  size_type num_elements;
  size_type num_buckets;
  ValInfo val_info;       // holds emptyval, and also the allocator
  pointer table;
};


// We need a global swap as well
template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
inline void swap(dense_hashtable<V,K,HF,ExK,SetK,EqK,A> &x,
                 dense_hashtable<V,K,HF,ExK,SetK,EqK,A> &y) {
  x.swap(y);
}

#undef JUMP_

template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
const typename dense_hashtable<V,K,HF,ExK,SetK,EqK,A>::size_type
  dense_hashtable<V,K,HF,ExK,SetK,EqK,A>::ILLEGAL_BUCKET;

// How full we let the table get before we resize.  Knuth says .8 is
// good -- higher causes us to probe too much, though saves memory.
// However, we go with .5, getting better performance at the cost of
// more space (a trade-off densehashtable explicitly chooses to make).
// Feel free to play around with different values, though.
template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
const int dense_hashtable<V,K,HF,ExK,SetK,EqK,A>::HT_OCCUPANCY_PCT = 50;

// How empty we let the table get before we resize lower.
// It should be less than OCCUPANCY_PCT / 2 or we thrash resizing
template <class V, class K, class HF, class ExK, class SetK, class EqK, class A>
const int dense_hashtable<V,K,HF,ExK,SetK,EqK,A>::HT_EMPTY_PCT
  = static_cast<int>(0.4 *
                     dense_hashtable<V,K,HF,ExK,SetK,EqK,A>::HT_OCCUPANCY_PCT);

_END_GOOGLE_NAMESPACE_

#endif /* _DENSEHASHTABLE_H_ */
